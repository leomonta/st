diff --git a/curr/st.c b/other/st.c
index cf5bc3f..92a2d27 100644
--- a/curr/st.c
+++ b/other/st.c
@@ -31,15 +31,13 @@
 
 /* Arbitrary sizes */
 #define UTF_INVALID 0xFFFD
-#define UTF_SIZ     4
-#define ESC_BUF_SIZ (128 * UTF_SIZ)
 #define ESC_ARG_SIZ 16
 #define STR_BUF_SIZ ESC_BUF_SIZ
 #define STR_ARG_SIZ ESC_ARG_SIZ
 
 /* macros */
 #define IS_SET(flag)   ((term.mode & (flag)) != 0)
-#define ISCONTROLC0(c) (BETWEEN(c, 0, 0x1f) || (c) == 0x7f)
+#define ISCONTROLC0(c) (BETWEEN(c, 0, 0x1f) || (c) == '\177')
 #define ISCONTROLC1(c) (BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)   (ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)     (u && wcschr(worddelimiters, u))
@@ -52,6 +50,7 @@ enum term_mode {
 	MODE_ECHO      = 1 << 4,
 	MODE_PRINT     = 1 << 5,
 	MODE_UTF8      = 1 << 6,
+	MODE_SIXEL     = 1 << 7,
 };
 
 enum cursor_movement {
@@ -78,11 +77,12 @@ enum charset {
 enum escape_state {
 	ESC_START      = 1,
 	ESC_CSI        = 2,
-	ESC_STR        = 4, /* DCS, OSC, PM, APC */
+	ESC_STR        = 4, /* OSC, PM, APC */
 	ESC_ALTCHARSET = 8,
 	ESC_STR_END    = 16, /* a final string was encountered */
 	ESC_TEST       = 32, /* Enter in test mode */
 	ESC_UTF8       = 64,
+	ESC_DCS        = 128,
 };
 
 typedef struct {
@@ -128,29 +128,27 @@ typedef struct {
 	int     charset;    /* current charset */
 	int     icharset;   /* selected charset for sequence */
 	int    *tabs;
-	Rune    lastc; /* last printed char outside of sequence, 0 if control */
 } Term;
 
 /* CSI Escape sequence structs */
 /* ESC '[' [[ [<priv>] <arg> [;]] <mode> [<mode>]] */
 typedef struct {
-	char   buf[ESC_BUF_SIZ]; /* raw string */
-	size_t len;              /* raw string length */
-	char   priv;
-	int    arg[ESC_ARG_SIZ];
-	int    narg; /* nb of args */
-	char   mode[2];
+	char buf[ESC_BUF_SIZ]; /* raw string */
+	int  len;              /* raw string length */
+	char priv;
+	int  arg[ESC_ARG_SIZ];
+	int  narg; /* nb of args */
+	char mode[2];
 } CSIEscape;
 
 /* STR Escape sequence structs */
 /* ESC type [[ [<priv>] <arg> [;]] <mode>] ESC '\' */
 typedef struct {
-	char   type; /* ESC type ... */
-	char  *buf;  /* allocated raw string */
-	size_t siz;  /* allocation size */
-	size_t len;  /* raw string length */
-	char  *args[STR_ARG_SIZ];
-	int    narg; /* nb of args */
+	char  type;             /* ESC type ... */
+	char  buf[STR_BUF_SIZ]; /* raw string */
+	int   len;              /* raw string length */
+	char *args[STR_ARG_SIZ];
+	int   narg; /* nb of args */
 } STREscape;
 
 static void execsh(char *, char **);
@@ -162,7 +160,6 @@ static void csidump(void);
 static void csihandle(void);
 static void csiparse(void);
 static void csireset(void);
-static void osc_color_response(int, int, int);
 static int  eschandle(uchar);
 static void strdump(void);
 static void strhandle(void);
@@ -188,18 +185,18 @@ static void    tputc(Rune);
 static void    treset(void);
 static void    tscrollup(int, int);
 static void    tscrolldown(int, int);
-static void    tsetattr(const int *, int);
-static void    tsetchar(Rune, const Glyph *, int, int);
+static void    tsetattr(int *, int);
+static void    tsetchar(Rune, Glyph *, int, int);
 static void    tsetdirt(int, int);
 static void    tsetscroll(int, int);
 static void    tswapscreen(void);
-static void    tsetmode(int, int, const int *, int);
+static void    tsetmode(int, int, int *, int);
 static int     twrite(const char *, int, int);
 static void    tfulldirt(void);
 static void    tcontrolcode(uchar);
 static void    tdectest(char);
 static void    tdefutf8(char);
-static int32_t tdefcolor(const int *, int *, int);
+static int32_t tdefcolor(int *, int *, int);
 static void    tdeftran(char);
 static void    tstrsequence(uchar);
 
@@ -209,7 +206,6 @@ static void selnormalize(void);
 static void selscroll(int, int);
 static void selsnap(int *, int *, int);
 
-static size_t utf8decode(const char *, Rune *, size_t);
 static Rune   utf8decodebyte(char, size_t *);
 static char   utf8encodebyte(Rune, size_t);
 static size_t utf8validate(Rune *, size_t);
@@ -228,10 +224,10 @@ static int       iofd = 1;
 static int       cmdfd;
 static pid_t     pid;
 
-static const uchar utfbyte[UTF_SIZ + 1] = {0x80, 0, 0xC0, 0xE0, 0xF0};
-static const uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
-static const Rune  utfmin[UTF_SIZ + 1]  = {0, 0, 0x80, 0x800, 0x10000};
-static const Rune  utfmax[UTF_SIZ + 1]  = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
+static uchar utfbyte[UTF_SIZ + 1] = {0x80, 0, 0xC0, 0xE0, 0xF0};
+static uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
+static Rune  utfmin[UTF_SIZ + 1]  = {0, 0, 0x80, 0x800, 0x10000};
+static Rune  utfmax[UTF_SIZ + 1]  = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
 ssize_t
 xwrite(int fd, const char *s, size_t len) {
@@ -268,13 +264,11 @@ xrealloc(void *p, size_t len) {
 }
 
 char *
-xstrdup(const char *s) {
-	char *p;
-
-	if ((p = strdup(s)) == NULL)
+xstrdup(char *s) {
+	if ((s = strdup(s)) == NULL)
 		die("strdup: %s\n", strerror(errno));
 
-	return p;
+	return s;
 }
 
 size_t
@@ -340,18 +334,29 @@ utf8validate(Rune *u, size_t i) {
 	return i;
 }
 
+static const char base64_digits[] = {
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0,
+    63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, -1, 0, 0, 0, 0, 1,
+    2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+    22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34,
+    35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
 char base64dec_getc(const char **src) {
-	while (**src && !isprint((unsigned char)**src))
-		(*src)++;
-	return **src ? *((*src)++) : '='; /* emulate padding if string ends */
+	while (**src && !isprint(**src)) (*src)++;
+	return *((*src)++);
 }
 
 char *
 base64dec(const char *src) {
-	size_t            in_len = strlen(src);
-	char             *result, *dst;
-	static const char base64_digits[256] = {
-	    [43] = 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51};
+	size_t in_len = strlen(src);
+	char  *result, *dst;
 
 	if (in_len % 4)
 		in_len += 4 - (in_len % 4);
@@ -362,10 +367,6 @@ base64dec(const char *src) {
 		int c = base64_digits[(unsigned char)base64dec_getc(&src)];
 		int d = base64_digits[(unsigned char)base64dec_getc(&src)];
 
-		/* invalid input. 'a' can be -1, e.g. if src is "\n" (c-str) */
-		if (a == -1 || b == -1)
-			break;
-
 		*dst++ = (a << 2) | ((b & 0x30) >> 4);
 		if (c == -1)
 			break;
@@ -476,9 +477,9 @@ int selected(int x, int y) {
 }
 
 void selsnap(int *x, int *y, int direction) {
-	int          newx, newy, xt, yt;
-	int          delim, prevdelim;
-	const Glyph *gp, *prevgp;
+	int    newx, newy, xt, yt;
+	int    delim, prevdelim;
+	Glyph *gp, *prevgp;
 
 	switch (sel.snap) {
 	case SNAP_WORD:
@@ -545,9 +546,9 @@ void selsnap(int *x, int *y, int direction) {
 
 char *
 getsel(void) {
-	char        *str, *ptr;
-	int          y, bufsize, lastx, linelen;
-	const Glyph *gp, *last;
+	char  *str, *ptr;
+	int    y, bufsize, lastx, linelen;
+	Glyph *gp, *last;
 
 	if (sel.ob.x == -1)
 		return NULL;
@@ -589,8 +590,7 @@ getsel(void) {
 		 * st.
 		 * FIXME: Fix the computer world.
 		 */
-		if ((y < sel.ne.y || lastx >= linelen) &&
-		    (!(last->mode & ATTR_WRAP) || sel.type == SEL_RECTANGULAR))
+		if ((y < sel.ne.y || lastx >= linelen) && !(last->mode & ATTR_WRAP))
 			*ptr++ = '\n';
 	}
 	*ptr = 0;
@@ -615,7 +615,7 @@ void die(const char *errstr, ...) {
 }
 
 void execsh(char *cmd, char **args) {
-	char                *sh, *prog, *arg;
+	char                *sh, *prog;
 	const struct passwd *pw;
 
 	errno = 0;
@@ -629,20 +629,13 @@ void execsh(char *cmd, char **args) {
 	if ((sh = getenv("SHELL")) == NULL)
 		sh = (pw->pw_shell[0]) ? pw->pw_shell : cmd;
 
-	if (args) {
+	if (args)
 		prog = args[0];
-		arg  = NULL;
-	} else if (scroll) {
-		prog = scroll;
-		arg  = utmp ? utmp : sh;
-	} else if (utmp) {
+	else if (utmp)
 		prog = utmp;
-		arg  = NULL;
-	} else {
+	else
 		prog = sh;
-		arg  = NULL;
-	}
-	DEFAULT(args, ((char *[]){prog, arg, NULL}));
+	DEFAULT(args, ((char *[]){prog, NULL}));
 
 	unsetenv("COLUMNS");
 	unsetenv("LINES");
@@ -678,7 +671,7 @@ void sigchld(int a) {
 		die("child exited with status %d\n", WEXITSTATUS(stat));
 	else if (WIFSIGNALED(stat))
 		die("child terminated due to signal %d\n", WTERMSIG(stat));
-	_exit(0);
+	exit(0);
 }
 
 void stty(char **args) {
@@ -703,7 +696,7 @@ void stty(char **args) {
 		perror("Couldn't call stty");
 }
 
-int ttynew(const char *line, char *cmd, const char *out, char **args) {
+int ttynew(char *line, char *cmd, char *out, char **args) {
 	int m, s;
 
 	if (out) {
@@ -734,15 +727,14 @@ int ttynew(const char *line, char *cmd, const char *out, char **args) {
 		break;
 	case 0:
 		close(iofd);
-		close(m);
 		setsid(); /* create a new process group */
 		dup2(s, 0);
 		dup2(s, 1);
 		dup2(s, 2);
 		if (ioctl(s, TIOCSCTTY, NULL) < 0)
 			die("ioctl TIOCSCTTY failed: %s\n", strerror(errno));
-		if (s > 2)
-			close(s);
+		close(s);
+		close(m);
 #ifdef __OpenBSD__
 		if (pledge("stdio getpw proc exec", NULL) == -1)
 			die("pledge\n");
@@ -766,25 +758,22 @@ size_t
 ttyread(void) {
 	static char buf[BUFSIZ];
 	static int  buflen = 0;
-	int         ret, written;
+	int         written;
+	int         ret;
 
 	/* append read bytes to unprocessed bytes */
-	ret = read(cmdfd, buf + buflen, LEN(buf) - buflen);
-
-	switch (ret) {
-	case 0:
-		exit(0);
-	case -1:
+	if ((ret = read(cmdfd, buf + buflen, LEN(buf) - buflen)) < 0)
 		die("couldn't read from shell: %s\n", strerror(errno));
-	default:
-		buflen += ret;
-		written = twrite(buf, buflen, 0);
-		buflen -= written;
-		/* keep any incomplete UTF-8 byte sequence for the next call */
-		if (buflen > 0)
-			memmove(buf, buf + written, buflen);
-		return ret;
-	}
+	buflen += ret;
+
+	written = twrite(buf, buflen, 0);
+	buflen -= written;
+	/* keep any uncomplete utf8 char for the next call */
+	if (buflen > 0)
+		memmove(buf, buf + written, buflen);
+
+	wlneeddraw();
+	return ret;
 }
 
 void ttywrite(const char *s, size_t n, int may_echo) {
@@ -879,7 +868,7 @@ void ttyresize(int tw, int th) {
 		fprintf(stderr, "Couldn't set window size: %s\n", strerror(errno));
 }
 
-void ttyhangup(void) {
+void ttyhangup() {
 	/* Send SIGHUP to shell */
 	kill(pid, SIGHUP);
 }
@@ -905,6 +894,8 @@ void tsetdirt(int top, int bot) {
 
 	for (i = top; i <= bot; i++)
 		term.dirty[i] = 1;
+
+	wlneeddraw();
 }
 
 void tsetdirtattr(int attr) {
@@ -1020,17 +1011,27 @@ void selscroll(int orig, int n) {
 	if (sel.ob.x == -1)
 		return;
 
-	if (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {
-		selclear();
-	} else if (BETWEEN(sel.nb.y, orig, term.bot)) {
-		sel.ob.y += n;
-		sel.oe.y += n;
-		if (sel.ob.y < term.top || sel.ob.y > term.bot ||
-		    sel.oe.y < term.top || sel.oe.y > term.bot) {
+	if (BETWEEN(sel.ob.y, orig, term.bot) || BETWEEN(sel.oe.y, orig, term.bot)) {
+		if ((sel.ob.y += n) > term.bot || (sel.oe.y += n) < term.top) {
 			selclear();
+			return;
+		}
+		if (sel.type == SEL_RECTANGULAR) {
+			if (sel.ob.y < term.top)
+				sel.ob.y = term.top;
+			if (sel.oe.y > term.bot)
+				sel.oe.y = term.bot;
 		} else {
-			selnormalize();
+			if (sel.ob.y < term.top) {
+				sel.ob.y = term.top;
+				sel.ob.x = 0;
+			}
+			if (sel.oe.y > term.bot) {
+				sel.oe.y = term.bot;
+				sel.oe.x = term.col;
+			}
 		}
+		selnormalize();
 	}
 }
 
@@ -1093,8 +1094,8 @@ void tmoveto(int x, int y) {
 	term.c.y = LIMIT(y, miny, maxy);
 }
 
-void tsetchar(Rune u, const Glyph *attr, int x, int y) {
-	static const char *vt100_0[62] = {
+void tsetchar(Rune u, Glyph *attr, int x, int y) {
+	static char *vt100_0[62] = {
 	    /* 0x41 - 0x7e */
 	    "↑", "↓", "→", "←", "█", "▚", "☃",      /* A - G */
 	    0, 0, 0, 0, 0, 0, 0, 0,                 /* H - O */
@@ -1197,7 +1198,7 @@ void tdeleteline(int n) {
 }
 
 int32_t
-tdefcolor(const int *attr, int *npar, int l) {
+tdefcolor(int *attr, int *npar, int l) {
 	int32_t idx = -1;
 	uint    r, g, b;
 
@@ -1245,7 +1246,7 @@ tdefcolor(const int *attr, int *npar, int l) {
 	return idx;
 }
 
-void tsetattr(const int *attr, int l) {
+void tsetattr(int *attr, int l) {
 	int     i;
 	int32_t idx;
 
@@ -1359,9 +1360,8 @@ void tsetscroll(int t, int b) {
 	term.bot = b;
 }
 
-void tsetmode(int priv, int set, const int *args, int narg) {
-	int        alt;
-	const int *lim;
+void tsetmode(int priv, int set, int *args, int narg) {
+	int alt, *lim;
 
 	for (lim = args + narg; args < lim; ++args) {
 		if (priv) {
@@ -1535,12 +1535,6 @@ void csihandle(void) {
 		if (csiescseq.arg[0] == 0)
 			ttywrite(vtiden, strlen(vtiden), 0);
 		break;
-	case 'b': /* REP -- if last char is printable print it <n> more times */
-		DEFAULT(csiescseq.arg[0], 1);
-		if (term.lastc)
-			while (csiescseq.arg[0]-- > 0)
-				tputc(term.lastc);
-		break;
 	case 'C': /* CUF -- Cursor <n> Forward */
 	case 'a': /* HPR -- Cursor <n> Forward */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -1662,18 +1656,11 @@ void csihandle(void) {
 	case 'm': /* SGR -- Terminal attribute (color) */
 		tsetattr(csiescseq.arg, csiescseq.narg);
 		break;
-	case 'n': /* DSR -- Device Status Report */
-		switch (csiescseq.arg[0]) {
-		case 5: /* Status Report "OK" `0n` */
-			ttywrite("\033[0n", sizeof("\033[0n") - 1, 0);
-			break;
-		case 6: /* Report Cursor Position (CPR) "<row>;<column>R" */
+	case 'n': /* DSR – Device Status Report (cursor position) */
+		if (csiescseq.arg[0] == 6) {
 			len = snprintf(buf, sizeof(buf), "\033[%i;%iR",
 			               term.c.y + 1, term.c.x + 1);
 			ttywrite(buf, len, 0);
-			break;
-		default:
-			goto unknown;
 		}
 		break;
 	case 'r': /* DECSTBM -- Set Scrolling Region */
@@ -1706,8 +1693,8 @@ void csihandle(void) {
 }
 
 void csidump(void) {
-	size_t i;
-	uint   c;
+	int  i;
+	uint c;
 
 	fprintf(stderr, "ESC[");
 	for (i = 0; i < csiescseq.len; i++) {
@@ -1731,40 +1718,9 @@ void csireset(void) {
 	memset(&csiescseq, 0, sizeof(csiescseq));
 }
 
-void osc_color_response(int num, int index, int is_osc4) {
-	int           n;
-	char          buf[32];
-	unsigned char r, g, b;
-
-	if (xgetcolor(is_osc4 ? num : index, &r, &g, &b)) {
-		fprintf(stderr, "erresc: failed to fetch %s color %d\n",
-		        is_osc4 ? "osc4" : "osc",
-		        is_osc4 ? num : index);
-		return;
-	}
-
-	n = snprintf(buf, sizeof buf, "\033]%s%d;rgb:%02x%02x/%02x%02x/%02x%02x\007",
-	             is_osc4 ? "4;" : "", num, r, r, g, g, b, b);
-	if (n < 0 || n >= sizeof(buf)) {
-		fprintf(stderr, "error: %s while printing %s response\n",
-		        n < 0 ? "snprintf failed" : "truncation occurred",
-		        is_osc4 ? "osc4" : "osc");
-	} else {
-		ttywrite(buf, n, 1);
-	}
-}
-
 void strhandle(void) {
 	char *p = NULL, *dec;
 	int   j, narg, par;
-	const struct {
-		int   idx;
-		char *str;
-	} osc_table[] = {
-	    {defaultfg, "foreground"},
-	    {defaultbg, "background"},
-	    {defaultcs, "cursor"    }
-    };
 
 	term.esc &= ~(ESC_STR_END | ESC_STR);
 	strparse();
@@ -1774,21 +1730,13 @@ void strhandle(void) {
 	case ']': /* OSC -- Operating System Command */
 		switch (par) {
 		case 0:
-			if (narg > 1) {
-				xsettitle(strescseq.args[1]);
-				xseticontitle(strescseq.args[1]);
-			}
-			return;
 		case 1:
-			if (narg > 1)
-				xseticontitle(strescseq.args[1]);
-			return;
 		case 2:
 			if (narg > 1)
 				xsettitle(strescseq.args[1]);
 			return;
 		case 52:
-			if (narg > 2 && allowwindowops) {
+			if (narg > 2) {
 				dec = base64dec(strescseq.args[2]);
 				if (dec) {
 					xsetsel(dec);
@@ -1798,39 +1746,16 @@ void strhandle(void) {
 				}
 			}
 			return;
-		case 10:
-		case 11:
-		case 12:
-			if (narg < 2)
-				break;
-			p = strescseq.args[1];
-			if ((j = par - 10) < 0 || j >= LEN(osc_table))
-				break; /* shouldn't be possible */
-
-			if (!strcmp(p, "?")) {
-				osc_color_response(par, osc_table[j].idx, 0);
-			} else if (xsetcolorname(osc_table[j].idx, p)) {
-				fprintf(stderr, "erresc: invalid %s color: %s\n",
-				        osc_table[j].str, p);
-			} else {
-				tfulldirt();
-			}
-			return;
 		case 4: /* color set */
 			if (narg < 3)
 				break;
 			p = strescseq.args[2];
 			/* FALLTHROUGH */
-		case 104: /* color reset */
+		case 104: /* color reset, here p = NULL */
 			j = (narg > 1) ? atoi(strescseq.args[1]) : -1;
-
-			if (p && !strcmp(p, "?")) {
-				osc_color_response(j, 0, 1);
-			} else if (xsetcolorname(j, p)) {
-				if (par == 104 && narg <= 1) {
-					xloadcols();
+			if (xsetcolorname(j, p)) {
+				if (par == 104 && narg <= 1)
 					return; /* color reset without parameter */
-				}
 				fprintf(stderr, "erresc: invalid color j=%d, p=%s\n",
 				        j, p ? p : "(null)");
 			} else {
@@ -1838,7 +1763,7 @@ void strhandle(void) {
 				 * TODO if defaultbg color is changed, borders
 				 * are dirty
 				 */
-				tfulldirt();
+				redraw();
 			}
 			return;
 		}
@@ -1847,6 +1772,7 @@ void strhandle(void) {
 		xsettitle(strescseq.args[0]);
 		return;
 	case 'P': /* DCS -- Device Control String */
+		term.mode |= ESC_DCS;
 	case '_': /* APC -- Application Program Command */
 	case '^': /* PM -- Privacy Message */
 		return;
@@ -1877,8 +1803,8 @@ void strparse(void) {
 }
 
 void strdump(void) {
-	size_t i;
-	uint   c;
+	int  i;
+	uint c;
 
 	fprintf(stderr, "ESC%c", strescseq.type);
 	for (i = 0; i < strescseq.len; i++) {
@@ -1902,10 +1828,7 @@ void strdump(void) {
 }
 
 void strreset(void) {
-	strescseq = (STREscape){
-	    .buf = xrealloc(strescseq.buf, STR_BUF_SIZ),
-	    .siz = STR_BUF_SIZ,
-	};
+	memset(&strescseq, 0, sizeof(strescseq));
 }
 
 void sendbreak(const Arg *arg) {
@@ -1943,8 +1866,8 @@ void tdumpsel(void) {
 }
 
 void tdumpline(int n) {
-	char         buf[UTF_SIZ];
-	const Glyph *bp, *end;
+	char   buf[UTF_SIZ];
+	Glyph *bp, *end;
 
 	bp  = &term.line[n][0];
 	end = &bp[MIN(tlinelen(n), term.col) - 1];
@@ -2008,9 +1931,12 @@ void tdectest(char c) {
 }
 
 void tstrsequence(uchar c) {
+	strreset();
+
 	switch (c) {
 	case 0x90: /* DCS -- Device Control String */
 		c = 'P';
+		term.esc |= ESC_DCS;
 		break;
 	case 0x9f: /* APC -- Application Program Command */
 		c = '_';
@@ -2022,7 +1948,6 @@ void tstrsequence(uchar c) {
 		c = ']';
 		break;
 	}
-	strreset();
 	strescseq.type = c;
 	term.esc |= ESC_STR;
 }
@@ -2063,7 +1988,6 @@ void tcontrolcode(uchar ascii) {
 		return;
 	case '\032': /* SUB */
 		tsetchar('?', &term.c.attr, term.c.x, term.c.y);
-		/* FALLTHROUGH */
 	case '\030': /* CAN */
 		csireset();
 		break;
@@ -2214,13 +2138,15 @@ void tputc(Rune u) {
 	Glyph *gp;
 
 	control = ISCONTROL(u);
-	if (u < 127 || !IS_SET(MODE_UTF8)) {
+	if (!IS_SET(MODE_UTF8) && !IS_SET(MODE_SIXEL)) {
 		c[0]  = u;
 		width = len = 1;
 	} else {
 		len = utf8encode(u, c);
-		if (!control && (width = wcwidth(u)) == -1)
+		if (!control && (width = wcwidth(u)) == -1) {
+			memcpy(c, "\357\277\275", 4); /* UTF_INVALID */
 			width = 1;
+		}
 	}
 
 	if (IS_SET(MODE_PRINT))
@@ -2235,12 +2161,24 @@ void tputc(Rune u) {
 	if (term.esc & ESC_STR) {
 		if (u == '\a' || u == 030 || u == 032 || u == 033 ||
 		    ISCONTROLC1(u)) {
-			term.esc &= ~(ESC_START | ESC_STR);
+			term.esc &= ~(ESC_START | ESC_STR | ESC_DCS);
+			if (IS_SET(MODE_SIXEL)) {
+				/* TODO: render sixel */;
+				term.mode &= ~MODE_SIXEL;
+				return;
+			}
 			term.esc |= ESC_STR_END;
 			goto check_control_code;
 		}
 
-		if (strescseq.len + len >= strescseq.siz) {
+		if (IS_SET(MODE_SIXEL)) {
+			/* TODO: implement sixel mode */
+			return;
+		}
+		if (term.esc & ESC_DCS && strescseq.len == 0 && u == 'q')
+			term.mode |= MODE_SIXEL;
+
+		if (strescseq.len + len >= sizeof(strescseq.buf) - 1) {
 			/*
 			 * Here is a bug in terminals. If the user never sends
 			 * some code to stop the str or esc command, then st
@@ -2254,10 +2192,7 @@ void tputc(Rune u) {
 			 * term.esc = 0;
 			 * strhandle();
 			 */
-			if (strescseq.siz > (SIZE_MAX - UTF_SIZ) / 2)
-				return;
-			strescseq.siz *= 2;
-			strescseq.buf = xrealloc(strescseq.buf, strescseq.siz);
+			return;
 		}
 
 		memmove(&strescseq.buf[strescseq.len], c, len);
@@ -2272,15 +2207,10 @@ check_control_code:
 	 * they must not cause conflicts with sequences.
 	 */
 	if (control) {
-		/* in UTF-8 mode ignore handling C1 control characters */
-		if (IS_SET(MODE_UTF8) && ISCONTROLC1(u))
-			return;
 		tcontrolcode(u);
 		/*
 		 * control codes are not shown ever
 		 */
-		if (!term.esc)
-			term.lastc = 0;
 		return;
 	} else if (term.esc & ESC_START) {
 		if (term.esc & ESC_CSI) {
@@ -2310,7 +2240,7 @@ check_control_code:
 		 */
 		return;
 	}
-	if (selected(term.c.x, term.c.y))
+	if (sel.ob.x != -1 && BETWEEN(term.c.y, sel.ob.y, sel.oe.y))
 		selclear();
 
 	gp = &term.line[term.c.y][term.c.x];
@@ -2320,10 +2250,8 @@ check_control_code:
 		gp = &term.line[term.c.y][term.c.x];
 	}
 
-	if (IS_SET(MODE_INSERT) && term.c.x + width < term.col) {
+	if (IS_SET(MODE_INSERT) && term.c.x + width < term.col)
 		memmove(gp + width, gp, (term.col - term.c.x - width) * sizeof(Glyph));
-		gp->mode &= ~ATTR_WIDE;
-	}
 
 	if (term.c.x + width > term.col) {
 		tnewline(1);
@@ -2331,15 +2259,10 @@ check_control_code:
 	}
 
 	tsetchar(u, &term.c.attr, term.c.x, term.c.y);
-	term.lastc = u;
 
 	if (width == 2) {
 		gp->mode |= ATTR_WIDE;
 		if (term.c.x + 1 < term.col) {
-			if (gp[1].mode == ATTR_WIDE && term.c.x + 2 < term.col) {
-				gp[2].u = ' ';
-				gp[2].mode &= ~ATTR_WDUMMY;
-			}
 			gp[1].u    = '\0';
 			gp[1].mode = ATTR_WDUMMY;
 		}
@@ -2357,7 +2280,7 @@ int twrite(const char *buf, int buflen, int show_ctrl) {
 	int  n;
 
 	for (n = 0; n < buflen; n += charsize) {
-		if (IS_SET(MODE_UTF8)) {
+		if (IS_SET(MODE_UTF8) && !IS_SET(MODE_SIXEL)) {
 			/* process a complete utf8 char */
 			charsize = utf8decode(buf + n, &u, buflen - n);
 			if (charsize == 0)
@@ -2467,7 +2390,6 @@ void resettitle(void) {
 
 void drawregion(int x1, int y1, int x2, int y2) {
 	int y;
-
 	for (y = y1; y < y2; y++) {
 		if (!term.dirty[y])
 			continue;
@@ -2478,7 +2400,7 @@ void drawregion(int x1, int y1, int x2, int y2) {
 }
 
 void draw(void) {
-	int cx = term.c.x, ocx = term.ocx, ocy = term.ocy;
+	int cx = term.c.x;
 
 	if (!xstartdraw())
 		return;
@@ -2494,14 +2416,12 @@ void draw(void) {
 	drawregion(0, 0, term.col, term.row);
 	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
 	            term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
-	term.ocx = cx;
-	term.ocy = term.c.y;
+	term.ocx = cx, term.ocy = term.c.y;
 	xfinishdraw();
-	if (ocx != term.ocx || ocy != term.ocy)
-		xximspot(term.ocx, term.ocy);
+	/* xximspot(term.ocx, term.ocy); */ /* disabled in wayland brach */
 }
 
 void redraw(void) {
 	tfulldirt();
-	draw();
+	/* draw();*/ /* Disabled in wayland */
 }
